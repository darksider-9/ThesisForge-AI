
import { ThesisContent } from "../types";
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Table, TableRow, TableCell, WidthType, BorderStyle } from "docx";
import saveAs from "file-saver";
import jsPDF from "jspdf";

// Handle both new masterDoc string format and legacy map format
const resolveContent = (content: ThesisContent | string): string => {
  if (typeof content === 'string') return content;
  if (content['final_draft']) return content['final_draft'];
  return Object.values(content).join('\n\n');
};

export const downloadDocx = async (content: ThesisContent | string) => {
  const fullText = resolveContent(content);
  const lines = fullText.split('\n');
  const children: (Paragraph | Table)[] = [];

  // Helper to check if a line looks like a table row (starts and ends with | or contains |)
  // Markdown tables usually look like: | Col 1 | Col 2 |
  const isTableLine = (line: string) => line.trim().startsWith('|');

  let inTable = false;
  let tableBuffer: string[] = [];

  const flushTable = () => {
    if (tableBuffer.length < 2) {
      // Not enough lines for a table, dump as text
      tableBuffer.forEach(l => {
         children.push(new Paragraph({ children: [new TextRun({ text: l, font: "Calibri", size: 24 })] }));
      });
    } else {
      // Parse Table
      // Filter out divider line (e.g. |---|---|)
      const validRows = tableBuffer.filter(row => !row.match(/^\|?\s*:?-+:?\s*\|/));
      
      const docxRows = validRows.map((rowStr, rowIndex) => {
        // Split by pipe, remove first/last empty if they exist due to leading/trailing pipe
        const cells = rowStr.split('|').map(c => c.trim());
        // Remove empty first/last if result of split on "| text |"
        if (cells[0] === '') cells.shift();
        if (cells[cells.length - 1] === '') cells.pop();

        return new TableRow({
          children: cells.map(cellText => new TableCell({
            children: [new Paragraph({ 
                children: [new TextRun({ 
                    text: cellText, 
                    bold: rowIndex === 0, // Header bold
                    font: "Calibri",
                    size: 22
                })],
                alignment: AlignmentType.CENTER
            })],
            width: { size: 100 / cells.length, type: WidthType.PERCENTAGE },
            margins: { top: 100, bottom: 100, left: 100, right: 100 }
          }))
        });
      });

      if (docxRows.length > 0) {
          children.push(new Table({
              rows: docxRows,
              width: { size: 100, type: WidthType.PERCENTAGE },
          }));
          children.push(new Paragraph({ text: "" })); // Spacing after table
      }
    }
    tableBuffer = [];
    inTable = false;
  };

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (isTableLine(line)) {
      inTable = true;
      tableBuffer.push(line);
      continue;
    } 
    
    // If we were in a table but this line is not a table line
    if (inTable && !isTableLine(line)) {
      flushTable();
    }

    // Process normal paragraph
    let headingLevel = undefined;
    let text = line;
    let isCentered = false;
    let isBold = false;
    let spacingAfter = 120;

    if (line.startsWith('# ')) {
        headingLevel = HeadingLevel.HEADING_1;
        text = line.replace('# ', '');
    } else if (line.startsWith('## ')) {
        headingLevel = HeadingLevel.HEADING_2;
        text = line.replace('## ', '');
    } else if (line.startsWith('### ')) {
        headingLevel = HeadingLevel.HEADING_3;
        text = line.replace('### ', '');
    } else if (line.trim().startsWith('>')) {
        // Captions
        text = line.replace('>', '').trim();
        isCentered = true;
        isBold = false;
        spacingAfter = 240; // More space after figure caption
    } else if (line.trim().startsWith('Figure') || line.trim().startsWith('Table') || line.trim().startsWith('图') || line.trim().startsWith('表')) {
        // Fallback detection for captions without '>'
        isCentered = true;
        isBold = true;
    }

    if (text.trim() === "") {
        // Skip empty lines unless needed for spacing, but docx handles spacing via params
        continue;
    }

    children.push(new Paragraph({
        children: [new TextRun({ text: text, font: "Calibri", size: 24, bold: isBold })],
        heading: headingLevel,
        alignment: isCentered ? AlignmentType.CENTER : AlignmentType.LEFT,
        spacing: { after: spacingAfter },
    }));
  }

  // Flush trailing table if doc ends with table
  if (inTable) {
    flushTable();
  }

  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        new Paragraph({
          children: [new TextRun({ text: "Generated by ThesisForge AI", bold: true, size: 20, color: "888888" })],
          alignment: AlignmentType.RIGHT,
          spacing: { after: 400 }
        }),
        ...children
      ],
    }],
  });

  const blob = await Packer.toBlob(doc);
  saveAs(blob, "Thesis_Master_Canvas.docx");
};

export const downloadPDF = (content: ThesisContent | string) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 15;
  let yPos = 20;

  const addBlock = (body: string) => {
    doc.setFontSize(11);
    doc.setFont("helvetica", "normal");
    
    const lines = body.split('\n');
    
    for (let line of lines) {
        if (yPos > 280) { doc.addPage(); yPos = 20; }

        let fontSize = 11;
        let fontStyle = "normal";
        let text = line;

        if (line.startsWith('# ')) {
            fontSize = 18; fontStyle = "bold"; text = line.replace('# ', '');
            yPos += 5;
        } else if (line.startsWith('## ')) {
            fontSize = 14; fontStyle = "bold"; text = line.replace('## ', '');
            yPos += 3;
        } else if (line.startsWith('### ')) {
            fontSize = 12; fontStyle = "bold"; text = line.replace('### ', '');
        }

        doc.setFontSize(fontSize);
        doc.setFont("helvetica", fontStyle);

        // Basic table skip for PDF (too complex for naive PDF generator)
        // Just print raw text for tables in PDF
        const splitText = doc.splitTextToSize(text, pageWidth - (margin * 2));
        doc.text(splitText, margin, yPos);
        
        yPos += (splitText.length * (fontSize / 2)) + 2; 
    }
  };

  const text = resolveContent(content);
  addBlock(text);

  doc.save("Thesis_Master_Canvas.pdf");
};

export const downloadPythonCode = (code: string) => {
  const blob = new Blob([code], { type: "text/x-python;charset=utf-8" });
  saveAs(blob, "thesis_builder.py");
};
